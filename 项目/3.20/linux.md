# 进程线程

详解：https://blog.csdn.net/wzl1217333452/article/details/108670054?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164752650316781685313377%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164752650316781685313377&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-108670054.142^v2^pc_search_result_control_group,143^v4^control&utm_term=linux%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B&spm=1018.2226.3001.4187

# 僵尸孤儿进程

**僵尸进程:** 子进程退出，父进程没有回收子进程资源（PCB），则子进程变成僵尸进程
**孤儿进程:** 父进程先于子进程结束，则子进程成为孤儿进程,子进程的父进程成为1号
进程init进程，称为init进程领养孤儿进程

一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还
保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止
则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这
些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变
量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状
态同时彻底清除掉这个进程。
如果一个进程已经终止，但是它的父进程尚未调用wait或waitpid对它进行清理，这时
的进程状态称为僵尸（Zombie）进程。任何进程在刚终止时都是僵尸进程，正常情况下，僵
尸进程都立刻被父进程清理了，为了观察到僵尸进程，我们自己写一个不正常的程序，父进
程fork出子进程，子进程终止，而父进程既不终止也不调用wait清理子进 程



# 锁

互斥锁，进行加锁解锁，其它进程只能排队等待，cpu会让其他进程进入休眠

自旋锁，其它线程不进入休眠，一直在询问能不能加锁，

读写锁 有高并发性，三种状态，读模式加锁，写模式加锁和不加锁

只要没有线程持有写锁，所有线程都可以申请读锁

只有在不加锁的状态下，才能成功申请写锁

条件变量 一个唤醒和全部唤醒

条件变量（条件变量id，互斥锁id）

条件变量有三个步骤，1.解锁2.阻塞，等待唤醒3.加锁

信号量


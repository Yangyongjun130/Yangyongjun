# c++程序编译

分为四个阶段：预处理，编译、优化，汇编，链接

预处理：处理#开头 的头文件，cpp转为.i文件

 展开所有的宏定义，消除“#define”；
 处理所有的预编译指令，比如#if、#ifdef等；
 处理#include预编译指令，将包含文件插入到该预编译的位置；
 删除所有的注释“/**/”、"//"等；
 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及错误提醒；
 保留所有的#program编译指令，原因是编译器要使用它们；

编译、优化：.i文件翻译为.s的汇编文件 词法分析，语法分析，语义分析

编译：编译.s文件转为.o的机器指令

链接：汇编.o文件，程序不会立即汇编，因为这个cpp文件中可能引用了其它cpp文件中的函数或者符号等，链接就是这些文件链接成一个整体，生成.exe文件也可能是linux的二进制文件，因为exe是windows的二进制文件。

链接分为两种：

**静态链接**：

在这种链接方式下，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。

**动态链接**

在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。

对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。

# 内存管理

堆 栈 静态/全局存储区 常量存储区 代码区

C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。

栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。

堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。

全局区/静态存储区（.bss 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。

常量存储区（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。
代码区（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

# 栈和堆的区别

申请方式：栈是系统自动分配，堆是程序员主动申请。
申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。
栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。
申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。
存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。

# 语言特性

## 变量

变量的四大类型：全局变量，静态全局变量，局部变量，静态局部变量。
全局变量：全局作用域：一个文件中定义，同属于一个程序的其他文件之中使用extern声明后也可使用。
静态全局变量：文件作用域，不同文件之间不共享。
局部变量：局部作用域，函数体执行完被销毁，存放在栈区。
静态局部变量：局部作用域，程序执行结束后被销毁。

## emplace_back与push_back

emplace_back()是c++11的新特性。
和push_back()的区别在于
push_back()方法要调用构造函数和复制构造函数，这也就代表着要先构造一个临时对象，然后把临时的copy构造函数拷贝或者移动到容器最后面。
而emplace_back()在实现时，则是直接在容器的尾部创建这个元素，省去了拷贝或移动元素的过程。

## extern

extern有两个作用

1.extern可以在函数或者变量前面加，声明这个变量或者函数可以在其它文件中使用

2.可以extern"C"{} 声明这是一个c代码，在编译时按照c代码来处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 



extern的原因：

c++有重载的定义，在编译时生成的函数名，不只是函数名，还会加上函数的参数，而c语言是没有重载定义的，编译时只包括函数名，c++调用一个用c代码写的函数，按照c++的编译方式来查找这个函数，就会出错。

## static

static修饰全局变量：这个变量只能在这个生命这个变量的文件使用。

static修饰函数：表名这个函数的作用域只能在这个文件里

static修饰类：

1.static修饰静待成员变量，静态成员变量也是放在全局存储区的，属于所有对象

2.在类内声明，但在类的外部初始化

3.静态成员变量可以作为静待成员函数的变量，而普通变量不可以

4.静态成员变量的类型可以是类的对象，非静态只能时对象的指针或者引用

5.静态成员函数1.不能调用非静态成员变量，因为函数没有this指针，不能进行访问类内2.静态成员函数不能声明为 虚函数（virtual）、const 函数和 volatile 函数 。

## volatile和const

volatile告诉优化器不要自以为是的优化，因为这个volatile的值随时可能改变，当使用到这个变量的时候，不是为了方便读取它在寄存器的备份，而是直接从内存读取它。

使用场景：

1.多线程的时候，为了使变量改变之后随时可以被其它线程看见，“可见性”。

2.中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 volatile 关键字修饰 

const, volatile区别

（1）const含义是“请做为常量使用”，而并非“放心吧，那肯定是个常量”，是不可修改的只读变量。 volatile的含义是“请不要做自以为是的优化，这个值可能变掉的”，而并非“你可以修改这个值”。

（2）const只在编译期有用，在运行期无用

const在编译期保证在C的“源代码”里面，没有对其修饰的变量进行修改的地方（如有则报错，编译不通过），而运行期该变量的值是否被改变则不受const的限制。

volatile在编译期和运行期都有用

在编译期告诉编译器：请不要做自以为是的优化，这个变量的值可能会变掉；

在运行期：每次用到该变量的值，都直接从内存中取该变量的值。

（3）const, volatile同时修饰一个变量

合法性

“volatile”的含义并非是“non-const”，volatile 和 const 不构成反义词，所以可以放一起修饰一个变量。

同时修饰一个变量的含义

表示一个变量在程序编译期不能被修改且不能被优化；在程序运行期，变量值可修改，但每次用到该变量的值都要从内存中读取，以防止意外错误

## const

1.const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。

2.const 修饰函数参数，使得传递过来的函数参数的值不能改变。

3.const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。

在类中的用法：

`const` 成员变量：

1. const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。

2. const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。

3. `const` 成员函数：

   不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。 不能调用非常量成员函数，以防修改成员变量的值。


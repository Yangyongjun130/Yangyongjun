# 

# 存储

页式存储管理**

逻辑空间分成若干大小相等的页面，物理内存空间也会分成和页面大小相等的物理块，以页面为单位把进程空间装进物理内存中分散的物理块

当有一个连续的逻辑空间，分布在多个页面中，大大降低了效率

所以有了

**段式存储管理**

逻辑空间划分为若干段

根据连续逻辑的长度决定

比如main 子函数

段表：段号，基址，段长

段比页更加灵活



段页式存储管理

先将逻辑空间划分为若干段

段在划分为若干页

页地址和段地址，段页地址 



## 缺页中断

磁盘->主存->缓存

程序是放在磁盘的，当程序运行时，将磁盘中的程序放入主存，在放入内存然后供cpu调用

但是当cpu执行的程序的数据发现没有在主存中，这一过程是根据页表中的状态位查看数据的页面是不是在内存中。每当所访问的页面不在内存时，**就会发生缺页中断，**这时候操作系统就会通过外存地址在外存中找到所缺的一页，调入内存。

磁盘属于外设，读写磁盘需要系统调用

保护cpu现场->分析中断的原因->中断处理->恢复cpu环境

在指令执行期间产生和处理中断信号

一条指令执行期间，可能产生多次缺页中断



在逻辑空间和物理空间都是以页面的方式存储内存，物理空间与逻辑空间的映射都是通过页表记录

页面一般大小为512b-k，linux 一般4k，过大会难以分配，过小页表管理空间大



## 页面置换算法

先进先出FIFO

LFU最不经常使用

额外空间记录缓存使用的频率



LRU最近最少使用算法

优先淘汰一段时间没有使用的字块

把当前访问的节点置于链表前面



# 文件系统

管理和存储文件

FAT文件系统

用表保存盘块的信息

存在链表管理

ntfs文件系统

对fat进行改进

EXT文件系统（linux）

扩展文件系统

EXT2/3/4数字表示第几代

包括Boost Sector和Block Group两个

Boost  Sector：启动扇区，安装开机管理程序

Block Group：块组，存储数据的实际位置

Block Group分为好几部分：

Superblock：

inodetable：

存放inode的地方，每个文件或者（目录）都有一个inode，是每一个文件（目录)的索引节点

inode保存了很多关于文件的信息：比如索引节点编号、文件类型、连接指针。。。。、



## 软连接和硬链接

硬链接是，linux文件识别主要是靠inode而不是靠文件名，一个inode可以有多个文件名，修改文件内容会影响每个文件名，删除文件名不会影响其它文件的访问

删除一个文件名，inode的连接数会减1，当这个值减到0，表示没有文件名指向这个inode，这首会回收inode号码，以及block区域

软连接

除了硬链接以外，还有一种特殊情况。

文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。

这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。



# 进程

为什么需要进程？

**进程是系统进行资源分配和调度的基本单位**

**进程作为程序独立运行的载体保障程序正常执行** 保证互相不干扰

进程的存在使得操作系统资源的利用率大幅提升



进程刚开始是存在磁盘上的一个可执行程序，当需要执行时，操作系统把它加载到内存上，然后通过寄存器，cpu执行程序

pcb时描述进程的一个结构体，在linux中是tack_struct

每个进程在运行的时候有自己的内存空间，一般为4G，3G用户，1G内核，task_struct就在这1G中

# 进程通信方式

管道

命名管道fifo

信号量

消息队列

共享内存

信号

socket



消息队列和管道基本上都是4次拷贝，而共享内存（mmap, shmget）只有两次。

4次：1，由用户空间的buf中将数据拷贝到内核中。2，内核将数据拷贝到内存中。3，内存到内核。4，内核到用户空间的buf.

2次： 1，用户空间到内存。 2，内存到用户空间。

消息队列和管道都是内核对象，所执行的操作也都是系统调用，而这些数据最终是要存储在内存中执行的。因此不可避免的要经过4次数据的拷贝。但是共享内存不同，当执行mmap或者shmget时，会在内存中开辟空间，然后再将这块空间映射到用户进程的虚拟地址空间中，即返回值为一个指向一个内存地址的指针。当用户使用这个指针时，例如赋值操作，会引起一个从虚拟地址到物理地址的转化，会将数据直接写入对应的物理内存中，省去了拷贝到内核中的过程。当读取数据时，也是类似的过程，因此总共有两次数据拷贝。

## 虚拟地址

进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。

进程开始要访问一个地址，它可能会经历下面的过程

每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录
页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了



虚拟地址空间其实就是用户地址空间

每个进程的pcb都存放于共享的内核中



pcb的内容

标识相关：pid，ppid等等
文件相关：进程需要记录打开的文件信息，于是需要文件描述符表
内存相关：内存指针，指向进程的虚拟地址空间（用户空间）信息
优先级相关：进程相对于其他进程的调度优先级
上下文信息相关：CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。
状态相关：进程当前的状态，说明该进程处于什么状态
信号相关：进程的信号处理函数，以及记录当前进程是否还有待处理的信号
I/O相关：记录进程与各种I/O设备之间的交互

进程状态

创建：分配pcb（进程控制块）->插入就绪队列 分配pcb但是其它资源还没就绪的状态

就绪状态：进程分配到除了cpu之外所有的必要资源，只要再获得cpu使用权可以运行

执行状态：进程获得cpu，进程正在运行

阻塞状态：因为某种原因，比如网卡，设备等无法执行，就会让出cpu给其他进程

终止状态：系统清理->pcb归还 首先将进程资源归还给操作系统，然后归还pcb



创建->就绪               终止

​		  /		\ \          /

   阻塞  <--  运行



# 线程

线程是比进程更小的独立运行的基本单位---线程

线程时操作系统进行调度的最小单位

线程在进程之中

一个进程可以并发多个线程

线程有tcb 线程控制块



进程为了方便操作系统管理，线程提升进程运行的并发量



线程切换：

当我们进行io操作时，cpu处理很快，但是io操作很慢，需要等待io操作完成，线程这个时候会执行其他的线程，线程切换需要保存现场等这样的开销很大

异步io

当数据到达时，再调用回调，但这样会形成分片

协程可以很好解决这个问题。比如 把一个IO操作写成一个协程。当触发IO操作的时候就自动让出CPU给其他协程。要知道协程的切换很轻的。协程通过这种对异步IO的封装 既保留了性能 也保证了代码的容易编写和可读性。在高IO密集型的程序下很好。但是高CPU密集型的程序下没啥好处。也说明了高IO密集型的服务适合协程

协程和线程差异：

协程其实可以认为是比线程更小的执行单元。为啥说他是一个执行单元，因为他自带CPU上下文。这样只要在合适的时机，我们可以把一个协程 切换到 另一个协程。只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。

一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。

线程进程都是同步机制，而协程则是异步

协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态


# 协程

（协作式线程）

上下文切换



比线程更小的粒度，运行效率更高，可以支持更高的并发

协程的本质是用户级线程

用户自行调度，内核无法干涉

让步



减少了上下文切换的成本

但是无法发挥cpu多核优势，因为内核不能干涉和感知

主要用于多io场景



# 内核态/用户态

内核态：

内核存放数据和代码的地方

进程执行操作系统内核的代码

cpu可以访问内存所有数据，包括外围设备

用户态：

用户空间：存放用户程序的代码和数据

用户执行自己的代码

cpu只能访问自己空间的数据，不允许访问别的资源，不允许访问外设



进程态->内核态

系统调用：

进程需要进入内核操作，系统调用这个程序进入内核态，处理完再返回

异常中断：

当出现异常时，操作系统进入内核态处理异常

外围设备中断：

读写外围设备，当完成之后，向操作系统发送信号，暂停cpu的操作，完成信号的操作后再返回

# 死锁

### **死锁是什么？**

死锁是多个进程运行时，会因为竞争不可剥夺的资源，进程一直僵持，不能推进，需要外界的条件。

比如A进程占有资源C需要资源D，B进程占有资源D需要资源C 两个进程都需要对方的资源才能够进行下去，但是两个进程现在谁都不动。

### **死锁发生的原因：**

1.竞争不可剥夺资源

信号可能也会造成死锁

A需要B发送信号才能运行，B需要A发送信号才能运行

2.进程间顺序非法



### **死锁发生的四个条件（缺一不可）**

1.互斥

在进程运行的时间里，这个进程的资源只能为它所占有

2.请求和保持

进程在因请求资源而阻塞，这时候进程的资源不释放一直保持

3.不可剥夺

进程的资源未使用之前，不能被剥夺，只能自己释放

4.环路等待条件

死锁发生时，必然存在一个进程-资源的环形链，每个进程都占有下一个进程请求的资源

 ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9BdjFkdlA5N1hkM1lpYWljblVOa1Z4WjNucHdjbmRhZzJHS0RpY2ljRkkxbHRHTjdZajVBU25LdEI5UTlDbzFneWdEWFJIS3BxTFlZNk5zV1FPcG5KUUFlV3cvNjQw?x-oss-process=image/format,png) 



### **死锁解决方法->针对四个必须条件：**

死锁预防：

1.资源一次性分配，为进程分配所有需要的资源，这样进程不会请求（破坏了请求条件）

2.只要进程有一个资源得不到分配，也不给这个进程分配其它的资源（破坏保持）

3.可剥夺资源：当某个进程获得了某部分的资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺）

4.资源有序分配： 系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）



**以确定的顺序获得锁：**

 如果必须获取多个锁，那么在设计的时候需要充分考虑不同线程之前获得锁的顺序。 

超时放弃

如果进程占有锁请求其它的锁，然后一段时间内没有请求到，那么进程就会放弃所有的锁， 



### **避免死锁的算法：**

1.判断系统“安全”法

在系统分配资源 之前，先判断此次资源分配的安全性，如果这次资源分配不安全，那么系统就不会分配资源，让进程等待，如果是安全的就分配资源给进程。

2.银行家算法

操作系统按照银行家指定的规则为进程分配资源，当进程首次申请分配时，先判断最大申请资源数，看进程能否现存的资源能否满足，如果能够满足，就为进程按申请量分配，否则就推迟分配。进程继续申请时，先判断进程现在占有的资源和本次申请的资源数的和是否大于进程所需最大进程数，如果大于则拒绝分配，否则再判断本次申请的资源数操作系统是否能满足，能满足就分配，否则还是推迟分配



### **死锁的检测**

资源分配

1、画出资源分配图

系统死锁，可利用资源分配图来描述。如下图所示，用长方形代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。

 

![img](https://img-blog.csdn.net/20180731103654409?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pnbTIwNDc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)![img](https://img-blog.csdn.net/20180731103816331?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pnbTIwNDc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

 

2、简化资源分配图

第一步：先看A资源，它有三个箭头是向外的，因此它一共给进程分配了3个资源，此时，A没有空闲的资源剩余。

第二步：再看B资源，它有一个箭头是向外的，因此它一共给进程分配了1个资源，此时，B还剩余一个空闲的资源没分配。 

第三步：看完资源，再来看进程，先看进程P2，它只申请一个A资源，但此时A资源已经用光了，所以，进程P2进入阻塞状态，因此，进程P2暂时不能化成孤立的点。 

第四步：再看进程P1，它只申请一个B资源，此时，系统还剩余一个B资源没分配，因此，可以满足P1的申请。这样，进程P1便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P1的所有的边去掉，变成一个孤立的点，如下图所示：

 

![img](https://img-blog.csdn.net/20180731103850412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pnbTIwNDc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

第五步：进程P1运行完后，释放其所占有的资源（2个A资源和1个B资源），系统回收这些资源后，空闲的资源便变成2个A资源和1个B资源，由于进程P2一直在申请一个A资源，所以此时，系统能满足它的申请。这样，进程P2便得到了它的全部所需资源，所以它不会进入阻塞状态，可以一直运行，等它运行完后，我们再把它的所有的资源释放。相当于：可以把P2的所有的边都去掉，化成一个孤立的点，变成下图： 

![img](https://img-blog.csdn.net/20180731103912949?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pnbTIwNDc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（若能消去图中所有的边，则称该图是**可完全简化**的，如上图）

3、使用死锁定理判断

**死锁定理：** 
**           **①如果资源分配图中没有环路，则系统没有死锁；** 
           **②如果资源分配图中出现了环路，则系统可能有死锁。****



### 死锁接触

1、资源剥夺法

挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。

2、撤销进程法

强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。

3、进程回退法

让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

# 进程线程

详解：https://blog.csdn.net/wzl1217333452/article/details/108670054?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164752650316781685313377%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164752650316781685313377&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-108670054.142^v2^pc_search_result_control_group,143^v4^control&utm_term=linux%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B&spm=1018.2226.3001.4187

# 僵尸孤儿进程

**僵尸进程:** 子进程退出，父进程没有回收子进程资源（PCB），则子进程变成僵尸进程
**孤儿进程:** 父进程先于子进程结束，则子进程成为孤儿进程,子进程的父进程成为1号
进程init进程，称为init进程领养孤儿进程

一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还
保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止
则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这
些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变
量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状
态同时彻底清除掉这个进程。
如果一个进程已经终止，但是它的父进程尚未调用wait或waitpid对它进行清理，这时
的进程状态称为僵尸（Zombie）进程。任何进程在刚终止时都是僵尸进程，正常情况下，僵
尸进程都立刻被父进程清理了，为了观察到僵尸进程，我们自己写一个不正常的程序，父进
程fork出子进程，子进程终止，而父进程既不终止也不调用wait清理子进程：



# io

**io 分为两个阶段 数据准备，将数据从内核（kernel）拷贝到进程中**

io类型

blocking

当进程调用了resv，kernel开始数据准备，kernel等待足够的数据到来，在用户进程会阻塞，等待数据准备好了，kernel将数据从内核拷贝到用户内存，kernel返回结果，用户解除blocking重新运行

nonblocking

通俗来讲，不会阻塞，一直如果kernel没准备好，返回error，然后再一直询问知道成功



 **IO multiplexing** 

select epoll

单个进程可以处理多个io，通过select/epoll不断询问socket有没有数据到达，有就通知进程

当任何一个socket准备好了，select返回，进程调用read，将数据拷贝，进程就运行

 **Asynchronous I/O** 

用户进程发起read后，不用管，去做别的事情，kernel收到read后，不会block进程，因为它是直接返回的，然后kernel会准备数据，将数据拷贝到内存，完成后发信号给进程，告诉它完成了。



io

计算密集型，也叫cpu密集型，完成一项任务的时间取决于cpu速度，cpu利用率高、其他事情处理慢

对cpu要求高，内存要求高，磁盘要求一般

io密集型，频繁读写网络、磁盘等任务，完成一项任务取决于io设备的速度，cpu利用率低，大部分时间在等待设备完成

磁盘读写速度要求高，内存要求高，对cpu要求不高



混合密集型

　　同步和异步针对应用程序来，关注的是程序中间的协作关系；阻塞与非阻塞更关注的是单个进程的执行状态。 同步异步更关注程序之间通信，阻塞非阻塞更关心程序在等待调用结果时的状态

# 同步异步

同步：执行一个操作之后，等待结果，然后才继续执行后续的操作。**

**异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作。**

**阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。**

**非阻塞：进程给CPU传达任我后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。这样的过程其实也叫轮询。**

**![img](https://images2015.cnblogs.com/blog/305504/201611/305504-20161119082936763-1104388837.png)**

 　阻塞、非阻塞、多路IO复用，都是同步IO，异步必定是非阻塞的，所以不存在异步阻塞和异步非阻塞的说法。真正的异步IO需要CPU的深度参与。换句话说，只有用户线程在操作IO的时候根本不去考虑IO的执行全部都交给CPU去完成，而自己只等待一个完成信号的时候，才是真正的异步IO。所以，拉一个子线程去轮询、去死循环，或者使用select、poll、epool，都不是异步。

### 案例

![1648733226417](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648733226417.png)



![1648733337685](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648733337685.png)

![1648733611623](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648733611623.png)

### 原子性

![1648734535615](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648734535615.png)

# 锁

乐观锁/悲观锁

![1648734774223](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648734774223.png)

上面是悲观锁下面乐观锁

悲观锁默认枷锁适合写操作

乐观锁默认不加锁适合读操作



![1648734981693](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648734981693.png)



公平锁/非公平锁（多线程）

![1648735066503](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648735066503.png)

非公平锁可以插队但是可能插队失败

![1648735146266](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648735146266.png)

![1648735260965](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648735260965.png)

![1648735289283](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648735289283.png)

### 互斥锁/自旋锁

互斥锁mutex

![1648735530299](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648735530299.png)

![1648735673563](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648735673563.png)



互斥锁会让出cpu

自旋锁不会让出cpu一直等在解锁

![1648735829583](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648735829583.png)

读写锁一般使用与多读少写

![1648735962788](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648735962788.png)

条件变量

![1648736035224](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648736035224.png)

![1648736112982](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648736112982.png)



# 进程之间通信方式

线程和进程通信方法不一样

原因：

进程是资源分配和调度的基本单位，线程是最小的调度单位，进程拥有自己的资源，线程共享同一份资源，所以各种锁是为了线程而发明的，进程不适用



![1648737061332](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648737061332.png)

![1648737081784](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648737081784.png)

![1648737256785](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648737256785.png)

有单机之间的消息队列，跨机之间进程通信

![1648737407265](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648737407265.png)

![1648737464862](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648737464862.png)

套接字也有单机跨机

网络套接字

有很多协议栈

![1648737699362](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648737699362.png)

![1648737751396](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648737751396.png)





# CAS与无锁数据结构

![1648738289827](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648738289827.png)



基于原子性

![1648775186571](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648775186571.png)

![1648738418306](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648738418306.png)

![1648775296599](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648775296599.png)

![1648775639808](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648775639808.png)

![1648775745612](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648775745612.png)



分布式锁

![1648776516791](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648776516791.png)

方案：

![1648776698993](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648776698993.png)





# socket

socket套接字，是一种特殊文件，socket函数可以对文件读写，打开，关闭，socket是接口，tcp/ip协议隐藏在socket接口后面，

套接字描述符：

描述套接字012 0标准输入 1标准输出 2标准错误输出

当应用程序要为网络通信创建一个socket时，操作系统返回一个小整数作为描述符来标识socket，然后应用程序以这个描述符作为参数，通过调用函数来完成某种操作





# 操作系统os

linux系统组成：内核、shell、文件系统、应用程序

内核是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、[内存](http://product.yesky.com/catalog/219/)、设备[驱动](http://drivers.yesky.com/)程序、文件和[网络](http://product.yesky.com/net/)系统，决定着系统的性能和稳定性。

Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。



内存管理：采用内存页，linux管理可用资源采用虚拟地址加物理地址

进程管理：进程是一个运行的应用程序，linux可以运行多个进程，在短时间间隔里轮流运行这些进程，时间间隔叫做“时间片”，让进程轮流运行的的方法叫做进程调度，完成进程调度的程序叫做调度程序

进程调度控制进程对cpu的使用，决定那个进程最值得运行

多进程，每个进程都有自己的进程空间，各个进程之间不干扰，但有时这些进程要完成特定任务，进程之间要进行通信，通信方式：信号，管道，共享内存，socket，信号量



# 存储器

缓存、 主存、辅存

缓存速度快位价高 》》》

局部性原理

cpu访问存储器时，无论是存储指令，还是存储数据，所访问的数据单元聚集在一个连续的小区域



cpu和主存之间增加一层速度快（容量小）的cache，改进贮存速度慢的情况

贮存和辅存，为主存增加存储容量

cache和贮存能直接与cpu交换信息，缓存需要通过主存



虚拟内存

替换策略主要发生咋主存cache层次和主存辅存层次

## 系统调用：

应用程序通过系统调用进入内核空间，用户要传输很多变量，参数给内核，内核态运行的时候也要保存应用程序的寄存器值、变量等 进程上下文：就是上述的内容

## 中断：

硬件通过一些信号等，导致内核调用中断程序，进入内核。硬件也可以传递一些参数和变量，保存环境



# select



# 磁盘冗余阵列

什么是服务器的RAID

利用虚拟化技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的是为了提升性能或者减少冗余或者两者都提升。

raid分级 

RAID 0

性能：是单块磁盘的N倍 有多少磁盘就是多少倍

不提供数据校验和数据冗余

如果磁盘损坏数据无法恢复

RAID1

数据无差别双写工作磁盘和镜像磁盘

性能是单块磁盘的N/2倍

数据可靠性强，数据只要不是同时损坏都可以恢复

![1648466791672](C:\Users\YANG\AppData\Roaming\Typora\typora-user-images\1648466791672.png)

RAID5

